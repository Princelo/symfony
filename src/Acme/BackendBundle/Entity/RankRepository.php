<?php

namespace Acme\BackendBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Acme\BackendBundle\Entity\Constant;
use Snc\RedisBundle\Doctrine\Cache\RedisCache;
use Predis\Client;
/**
 * RankRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RankRepository extends EntityRepository
{
    public function getArrNewestRankList($intZone, $intCount, $intTermNo, $strWhere = '', $cache_time = 0)
    {
        $strTop = $intZone==0?"intTopRankPRC":"intTopRankHKTW";
        $query = $this->getEntityManager()
            ->createQuery(
                "SELECT s.strTitle title,
                        s.arrStrArtistName artists,
                        s.id id,
                        s.{$strTop} top,
                        s.strCorpName corp,
                        {$intZone} zone,
                        r.intIndex rank_index,
                        r.intLastIndex last_rank_index,
                        r.intCountOnList count_on_list,
                        COALESCE(r.intScore, 0) score,
                        r.boolIsPrePlus is_pre,
                        s.strSongFile file,
                        {$intTermNo} term_no,
                        COUNT(rl.id) champion_count,
                        COUNT(vl.id) fm_count,
                        CASE WHEN MIN(rv.intIndex) = 0
                             THEN 1
                             ELSE MIN(rv.intIndex)
                             END AS top_index
                    FROM
                    AcmeBackendBundle:Rank r
                    JOIN r.song s
                    LEFT JOIN AcmeBackendBundle:Rank rl
                    WITH r.intTermNo = rl.intTermNo
                         AND rl.song = s
                         AND rl.intZone = r.intZone
                         AND rl.intIndex = 1
                    LEFT JOIN AcmeBackendBundle:Rank rv
                        WITH rv.song = s
                    LEFT JOIN AcmeBackendBundle:Votelog vl
                    WITH vl.intTermNo = r.intTermNo
                        AND vl.intSongId = s.id
                        AND vl.intZone = r.intZone
                    WHERE r.intZone = {$intZone}
                    AND r.intTermNo = {$intTermNo}
                    {$strWhere}
                    GROUP BY title, artists, id, top, corp, file, rank_index, last_rank_index, count_on_list, score
                             , is_pre
                    ORDER BY r.intIndex ASC
                    "
            )
            ->setMaxResults($intCount);
        if($cache_time > 0) {
            $predis = new RedisCache();
            $predis->setRedis(new Client());
            $cache_lifetime = $cache_time;
            $query
                ->setResultCacheDriver($predis)
                ->setResultCacheLifetime($cache_lifetime);
        }
        return $query->getResult();
    }

    public function generateRank($arrIntTerm)
    {
        return $this->getEntityManager()
            ->createQuery(
            "
                UPDATE AcmeBackendBundle:Rank r
                (r.intTermNo, r.intScore, r.intZone, r.intIndex, r.intLastIndex, r.intCountOnList, r.song_id)
                SELECT
                {$arrIntTerm[0]},
                    (
                        SELECT COUNT*4*(11-lv.intIndex)+(CASE WHEN(
                            s.boolIsPremirere = true
                        ) THEN 300 ELSE 0 END)
                         FROM AcmeBackendBundle:Votelog lv WHERE intTermNo = {$arrIntTerm[0]} AND lv.intSongId = s.id
                            AND lv.intZone = 0
                    ) AS score,
                    0,
                    1,
                    1,
                    (
                        SELECT COUNT FROM AcmeBackendBundle:Rank lr WHERE lr.song_id = s.id AND lr.intTermNo < {$arrIntTerm{0}}
                    ) AS intCountRank,
                    {$arrIntTerm[0]} AS song_id
                FROM AcmeBackendBundle:Song s


            "
            )
            ->execute();
    }
}
